<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Royale - Multiplayer Tournament</title>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 50%, #121213 100%);
            min-height: 100vh;
            color: #ffffff;
            overflow-x: hidden;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 4rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 25%, #e8e8e8 75%, #d0d0d0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: -0.03em;
            position: relative;
            display: inline-block;
        }

        .title::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 25%, #e8e8e8 75%, #d0d0d0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: blur(8px);
            opacity: 0.5;
            z-index: -1;
        }

        .title::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            z-index: -2;
            border-radius: 50%;
        }

        .game-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: linear-gradient(145deg, #2a2a2c 0%, #1e1e20 100%);
            border-radius: 20px;
            padding: 24px 28px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 
                0 8px 32px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -1px 0 rgba(0,0,0,0.3);
        }

        .stat-number {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 6px;
            color: #ffffff;
            letter-spacing: -0.02em;
        }

        .stat-label {
            font-size: 0.875rem;
            font-weight: 500;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #b0b0b0;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 32px;
            align-items: stretch;
        }

        .wordle-container {
            background: linear-gradient(145deg, #1a1a1c 0%, #0f0f10 100%);
            border-radius: 24px;
            padding: 36px;
            color: white;
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.05),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
        }

        .word-grid {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            gap: 5px;
            margin-bottom: 30px;
            max-width: 350px;
            margin-left: auto;
            margin-right: auto;
        }

        .word-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
        }

        .letter-cell {
            width: 62px;
            height: 62px;
            border: 2px solid #3a3a3c;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 8px;
            transition: border-color 0.2s ease;
            background: #121213;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .letter-cell.filled {
            border-color: #565758;
            animation: pop 0.1s ease-in-out;
        }

        .letter-cell.correct {
            background-color: #538d4e !important;
            border-color: #538d4e !important;
            color: white !important;
        }

        .letter-cell.present {
            background-color: #b59f3b !important;
            border-color: #b59f3b !important;
            color: white !important;
        }

        .letter-cell.absent {
            background-color: #3a3a3c !important;
            border-color: #3a3a3c !important;
            color: white !important;
        }

        .letter-cell.garbage {
            background-color: #dc2626 !important;
            border-color: #dc2626 !important;
            color: white !important;
            font-size: 1.5rem;
            font-weight: 900;
        }

        .letter-cell.garbage::after {
            content: '✕';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-weight: 900;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes flip {
            0% { 
                transform: rotateX(0deg);
            }
            50% { 
                transform: rotateX(-90deg);
            }
            100% { 
                transform: rotateX(0deg);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .letter-cell.flipping {
            animation: flip 0.6s ease-in-out;
        }

        .word-row.shake {
            animation: shake 0.5s ease-in-out;
        }

        .keyboard {
            max-width: 500px;
            margin: 0 auto;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 8px;
        }

        .key {
            height: 58px;
            border-radius: 4px;
            border: none;
            background: #818384;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            color: white;
            font-size: 12px;
        }

        .key:hover {
            background: #565758;
        }
        
        .key.correct {
            background: #538d4e !important;
        }
        
        .key.present {
            background: #b59f3b !important;
        }
        
        .key.absent {
            background: #3a3a3c !important;
        }

        .key.wide {
            flex: 1.5;
            font-size: 12px;
        }

        .key.letter {
            flex: 1;
            min-width: 43px;
        }

        .sidebar {
            background: #818384;
            border-radius: 20px;
            padding: 20px;
            border: 1px solid #3a3a3c;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .opponent-section {
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(145deg, #3a3a3c, #2d2d2f);
            border-radius: 12px;
            text-align: center;
            border: 1px solid #4a4a4c;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2),
                0 4px 12px rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .opponent-section:hover {
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2),
                0 6px 16px rgba(0,0,0,0.4),
                0 3px 6px rgba(0,0,0,0.3);
        }

        .opponent-name {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #b59f3b;
        }

        .opponent-grid {
            display: grid !important;
            grid-template-rows: repeat(6, 1fr);
            gap: 3px;
            max-width: 150px;
            margin: 0 auto;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .opponent-row {
            display: grid !important;
            grid-template-columns: repeat(5, 1fr);
            gap: 3px;
            visibility: visible !important;
        }

        .opponent-cell {
            width: 25px;
            height: 25px;
            border: 2px solid #3a3a3c;
            border-radius: 4px;
            background: #121213;
            box-sizing: border-box;
        }

        .opponent-cell.correct {
            background-color: #538d4e !important;
            border: 2px solid #3a3a3c !important;
            border-radius: 4px !important;
            width: 25px !important;
            height: 25px !important;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 1px 2px rgba(0,0,0,0.3) !important;
        }

        .opponent-cell.present {
            background-color: #b59f3b !important;
            border: 2px solid #3a3a3c !important;
            border-radius: 4px !important;
            width: 25px !important;
            height: 25px !important;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.2),
                0 1px 2px rgba(0,0,0,0.3) !important;
        }

        .opponent-cell.absent {
            background-color: #4a4a4c !important;
            border: 2px solid #565758 !important;
            border-radius: 4px !important;
            width: 25px !important;
            height: 25px !important;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2),
                0 1px 2px rgba(0,0,0,0.3) !important;
        }

        /* Force opponent cells to always be visible - Updated 2025-09-06 */
        .opponent-cell {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Additional override to ensure opponent cells maintain consistent styling */
        .opponent-grid .opponent-row .opponent-cell {
            border: 2px solid #3a3a3c !important;
            border-radius: 4px !important;
            box-sizing: border-box !important;
        }

        .match-info {
            background: #538d4e;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .match-timer {
            font-size: 1.3rem;
            font-weight: bold;
            color: white;
        }

        .tournament-info {
            background: #3a3a3c;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .countdown-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #538d4e;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #b59f3b;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .players-list {
            margin-bottom: 30px;
        }

        .players-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: #3a3a3c;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .player-item.you {
            background: #538d4e;
            border: 1px solid #6aaa64;
        }

        .player-item.eliminated {
            opacity: 0.5;
            background: #3a3a3c;
            text-decoration: line-through;
        }

        .player-name {
            font-weight: bold;
        }

        .player-score {
            background: #121213;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
        }

        .game-controls {
            text-align: center;
        }

        .btn {
            background: linear-gradient(145deg, #538d4e 0%, #4a7c44 100%);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: none;
            letter-spacing: 0.02em;
            box-shadow: 
                0 4px 16px rgba(83, 141, 78, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.2),
                inset 0 -1px 0 rgba(0,0,0,0.1);
            min-width: 140px;
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: linear-gradient(145deg, #6aaa64 0%, #5a8f54 100%);
            transform: translateY(-1px);
            box-shadow: 
                0 8px 25px rgba(83, 141, 78, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.25),
                inset 0 -1px 0 rgba(0,0,0,0.15);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 
                0 2px 8px rgba(83, 141, 78, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2);
        }

        .btn:disabled {
            background: linear-gradient(145deg, #2a2a2c 0%, #1e1e20 100%);
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: 
                0 2px 8px rgba(0,0,0,0.2),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }

        .message {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
        }

        .message.success {
            background: #538d4e;
            color: white;
            border: 1px solid #6aaa64;
        }

        .message.error {
            background: #3a3a3c;
            color: white;
            border: 1px solid #565758;
        }

        .message.info {
            background: #818384;
            color: white;
            border: 1px solid #3a3a3c;
        }

        .timer {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 24px;
            color: #f4d03f;
            text-shadow: 
                0 2px 4px rgba(0,0,0,0.4),
                0 0 8px rgba(244, 208, 63, 0.3);
            letter-spacing: 0.02em;
        }

        .game-setup {
            background: linear-gradient(145deg, #2a2a2c 0%, #1e1e20 100%);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 520px;
            margin: 60px auto;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .game-setup h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 24px;
            letter-spacing: -0.02em;
        }

        .input-field {
            width: 100%;
            padding: 16px 20px;
            margin: 12px 0;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            background: linear-gradient(145deg, #1a1a1c 0%, #0f0f10 100%);
            color: white;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            font-family: inherit;
            transition: all 0.25s ease;
            box-shadow: 
                inset 0 2px 4px rgba(0,0,0,0.1),
                0 1px 3px rgba(0,0,0,0.2);
        }

        .input-field:focus {
            outline: none;
            border-color: rgba(83, 141, 78, 0.6);
            box-shadow: 
                inset 0 2px 4px rgba(0,0,0,0.1),
                0 0 0 3px rgba(83, 141, 78, 0.1),
                0 1px 3px rgba(0,0,0,0.2);
            background: linear-gradient(145deg, #1e1e20 0%, #141416 100%);
        }

        .input-field::placeholder {
            color: rgba(255,255,255,0.4);
        }

        .button-group {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 28px;
            flex-wrap: wrap;
        }

        .connection-status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: #538d4e;
        }

        .connection-status.disconnected {
            background: #d73027;
        }

        .connection-status.connecting {
            background: #b59f3b;
        }

        .hidden {
            display: none;
        }

        .game-id-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background: #3a3a3c;
            border-radius: 10px;
        }

        .game-id-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #b59f3b;
            font-family: monospace;
            letter-spacing: 2px;
        }

        .copy-btn {
            background: #538d4e;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: #6aaa64;
            transform: scale(1.05);
        }

        .copy-btn.copied {
            background: #b59f3b;
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .letter-cell {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">WORD ROYALE</h1>
            <div id="connectionStatus" class="connection-status connecting">Connecting to server...</div>
        </div>

        <!-- Main Menu Screen -->
        <div id="mainMenu" class="game-setup">
            <h2>Choose Game Mode</h2>
            <div class="button-group" style="flex-direction: column; gap: 20px;">
                <button class="btn" onclick="showPublicMatchmaking()" style="padding: 20px 40px; font-size: 1.2rem; background: linear-gradient(135deg, #ff6b6b, #ee5a24);">
                    🔥 Join Public Battle Royale
                    <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.9;">Tetris 99-style: 100 players, 15 minutes, garbage system</div>
                </button>
                <button class="btn" onclick="showCustomGame()" style="padding: 20px 40px; font-size: 1.2rem;">
                    🏠 Custom Tournament
                    <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.8;">Create or join private tournament rooms</div>
                </button>
            </div>
        </div>

        <!-- Public Battle Royale Screen -->
        <div id="publicMatchmaking" class="game-setup hidden">
            <h2>🔥 Public Battle Royale</h2>
            <div class="info-card" style="margin-bottom: 20px; padding: 20px; background: linear-gradient(145deg, #2a2a2c, #1a1a1c); border-radius: 12px; border: 1px solid #ff6b6b;">
                <h3 style="color: #ff6b6b; margin-bottom: 15px;">Battle Royale Rules</h3>
                <ul style="text-align: left; line-height: 1.6; color: #e0e0e0;">
                    <li><strong>100 players, 15 minutes</strong> - Last player standing wins</li>
                    <li><strong>Random opponents</strong> - Get matched with different players</li>
                    <li><strong>Garbage system</strong> - Complete words to send garbage rows to opponents</li>
                    <li><strong>Instant KO</strong> - First-try completion eliminates opponent immediately</li>
                </ul>
            </div>
            <input type="text" id="publicPlayerName" class="input-field" placeholder="Enter your name" maxlength="20">
            <div id="publicMatchStatus" class="message info">Ready to join the Battle Royale!</div>
            <div class="button-group">
                <button class="btn" id="findMatchBtn" onclick="findPublicMatch()" style="background: linear-gradient(135deg, #ff6b6b, #ee5a24);">🔥 Join Battle Royale</button>
                <button class="btn" onclick="backToMainMenu()">Back</button>
            </div>
        </div>

        <!-- Custom Game Setup Screen -->
        <div id="gameSetup" class="game-setup hidden">
            <h2>Custom Room</h2>
            <input type="text" id="playerName" class="input-field" placeholder="Enter your name" maxlength="20">
            <input type="text" id="gameId" class="input-field" placeholder="Game ID (optional - leave empty to create new game)" maxlength="50">
            <div class="button-group">
                <button class="btn" onclick="createGame()">Create Room</button>
                <button class="btn" onclick="joinGame()">Join Room</button>
                <button class="btn" onclick="backToMainMenu()">Back</button>
            </div>
        </div>

        <!-- Game Lobby Screen -->
        <div id="gameLobby" class="game-setup hidden">
            <h2>Game Lobby</h2>
            <div id="gameIdContainer" class="game-id-container">
                <span>Game ID:</span>
                <span id="lobbyGameId" class="game-id-text">ABC123</span>
                <button id="copyGameIdBtn" class="copy-btn" onclick="copyGameId()">📋 Copy</button>
            </div>
            <p id="lobbyPlayerCount">Players: 0/100</p>
            <div id="lobbyPlayerList"></div>
            <div class="button-group">
                <button class="btn" id="startGameBtn" onclick="startMultiplayerGame()">Start Game</button>
                <button class="btn" onclick="leaveGame()">Leave Game</button>
            </div>
        </div>

        <!-- Main Game Area -->
        <div id="mainGame" class="hidden">
            <div class="game-stats">
                <div class="stat-card">
                    <div class="stat-number" id="playersAlive">100</div>
                    <div class="stat-label">Players Alive</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="yourRank">1</div>
                    <div class="stat-label">Your Rank</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="roundNumber">1</div>
                    <div class="stat-label">Round</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="yourScore">0</div>
                    <div class="stat-label" id="scoreLabel">Match Score</div>
                </div>
            </div>

        <!-- Series Score for Public Matches -->
        <div id="seriesScore" class="game-stats hidden" style="margin-bottom: 20px; justify-content: center;">
            <div class="stat-card" style="background: #538d4e;">
                <div class="stat-number" id="player1Wins">0</div>
                <div class="stat-label" id="player1Name">Player 1</div>
            </div>
            <div style="display: flex; align-items: center; color: white; font-size: 1.5rem; margin: 0 20px;">
                Best of 5
            </div>
            <div class="stat-card" style="background: #b59f3b;">
                <div class="stat-number" id="player2Wins">0</div>
                <div class="stat-label" id="player2Name">Player 2</div>
            </div>
        </div>

        <div class="timer" id="timer">Tournament starting...</div>

        <div class="game-area">
            <div class="wordle-container">
                <div id="message" class="message info">Tournament mode: Beat your opponent in 1v1 matches to advance!</div>
                
                <div class="word-grid" id="wordGrid"></div>

                <div class="keyboard" id="keyboard">
                    <div class="keyboard-row">
                        <button class="key letter" onclick="handleKey('Q')">Q</button>
                        <button class="key letter" onclick="handleKey('W')">W</button>
                        <button class="key letter" onclick="handleKey('E')">E</button>
                        <button class="key letter" onclick="handleKey('R')">R</button>
                        <button class="key letter" onclick="handleKey('T')">T</button>
                        <button class="key letter" onclick="handleKey('Y')">Y</button>
                        <button class="key letter" onclick="handleKey('U')">U</button>
                        <button class="key letter" onclick="handleKey('I')">I</button>
                        <button class="key letter" onclick="handleKey('O')">O</button>
                        <button class="key letter" onclick="handleKey('P')">P</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key letter" onclick="handleKey('A')">A</button>
                        <button class="key letter" onclick="handleKey('S')">S</button>
                        <button class="key letter" onclick="handleKey('D')">D</button>
                        <button class="key letter" onclick="handleKey('F')">F</button>
                        <button class="key letter" onclick="handleKey('G')">G</button>
                        <button class="key letter" onclick="handleKey('H')">H</button>
                        <button class="key letter" onclick="handleKey('J')">J</button>
                        <button class="key letter" onclick="handleKey('K')">K</button>
                        <button class="key letter" onclick="handleKey('L')">L</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key wide" onclick="handleKey('ENTER')">ENTER</button>
                        <button class="key letter" onclick="handleKey('Z')">Z</button>
                        <button class="key letter" onclick="handleKey('X')">X</button>
                        <button class="key letter" onclick="handleKey('C')">C</button>
                        <button class="key letter" onclick="handleKey('V')">V</button>
                        <button class="key letter" onclick="handleKey('B')">B</button>
                        <button class="key letter" onclick="handleKey('N')">N</button>
                        <button class="key letter" onclick="handleKey('M')">M</button>
                        <button class="key wide" onclick="handleKey('BACKSPACE')">⌫</button>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <!-- Tournament Info -->
                <div id="tournamentInfo" class="tournament-info hidden">
                    <h3>Tournament Progress</h3>
                    <div>Round <span id="tournamentRound">1</span></div>
                    <div><span id="activeMatches">0</span> active matches</div>
                </div>

                <!-- Current Match Info -->
                <div id="matchInfo" class="match-info hidden">
                    <div class="match-timer" id="matchTimer">1:30</div>
                    <div><span id="yourName">You</span> VS <span id="opponentName">Opponent</span></div>
                </div>

                <!-- Opponent Progress (Tetris 99 style) -->
                <div id="opponentSection" class="opponent-section hidden">
                    <div class="opponent-name" id="opponentDisplayName">Opponent</div>
                    <div class="opponent-grid" id="opponentGrid"></div>
                </div>

                <div class="players-list">
                    <h3 class="players-title">Players Remaining</h3>
                    <div id="playersList"></div>
                </div>

                <div class="game-controls">
                    <button class="btn" onclick="leaveGame()">Leave Game</button>
                </div>
            </div>
        </div>
        </div> <!-- End mainGame -->
    </div>

    <script>
        // Multiplayer game state
        let socket = null;
        let gameState = {
            gameId: null,
            playerId: null,
            playerName: '',
            currentGuess: '',
            currentRow: 0,
            gameStatus: 'waiting', // waiting, playing, ended
            players: [],
            playersAlive: 0,
            yourRank: 1,
            round: 1,
            score: 0,
            connected: false,
            tournamentMode: true,
            currentMatch: null, // Will contain match info including opponent and timer
            clientTimer: 0, // Client-side timer for real-time countdown
            timerInterval: null, // Client timer interval
            publicMatchmaking: false, // Whether in public matchmaking mode
            matchmakingInterval: null // Public matchmaking polling interval
        };

        // Socket.io connection
        function initializeSocket() {
            // Connect to server - auto-detect environment
            const currentHost = window.location.hostname;
            const protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';
            
            let serverUrl;
            if (currentHost === 'localhost' || currentHost === '127.0.0.1') {
                serverUrl = 'http://localhost:3000';
            } else if (currentHost.includes('railway.app') || currentHost.includes('up.railway.app')) {
                serverUrl = `${protocol}${currentHost}`;
            } else {
                serverUrl = `${protocol}${currentHost}:3000`;
            }
            console.log('Attempting to connect to:', serverUrl);
            
            socket = io(serverUrl, {
                autoConnect: true,
                reconnection: true,
                timeout: 10000
            });
            
            socket.on('connect', () => {
                console.log('✅ Connected to server successfully!');
                gameState.connected = true;
                updateConnectionStatus();
            });

            socket.on('disconnect', (reason) => {
                console.log('❌ DISCONNECT EVENT - Reason:', reason);
                console.log('❌ Had game state - GameID:', gameState.gameId, 'PlayerID:', gameState.playerId);
                gameState.connected = false;
                updateConnectionStatus();
                
                // Try to reconnect if we had a game
                if (gameState.gameId || gameState.playerId) {
                    console.log('❌ Connection lost, attempting to reconnect...');
                    showMessage('Connection lost, reconnecting...', 'error');
                    
                    setTimeout(() => {
                        console.log('🔄 Attempting to reconnect...');
                        initializeSocket();
                    }, 2000);
                }
            });

            socket.on('gameUpdate', (serverGameState) => {
                console.log('📡 Received game update:', serverGameState);
                console.log('📡 Game status:', serverGameState.status);
                console.log('📡 Players in update:', serverGameState.players?.length || 0);
                updateGameFromServer(serverGameState);
            });

            socket.on('connect_error', (error) => {
                console.error('🔥 Connection error:', error);
                gameState.connected = false;
                updateConnectionStatus();
                showMessage('Failed to connect to server. Make sure the server is running on localhost:3000', 'error');
            });

            socket.on('error', (error) => {
                console.error('🔥 Socket error:', error);
                showMessage('Socket connection error: ' + error.message, 'error');
            });

            // Public matchmaking event handlers
            socket.on('queueStatus', (status) => {
                console.log('📊 Queue status update:', status);
                if (status.inQueue) {
                    const waitTime = status.estimatedWaitTime > 0 ? ` (~${status.estimatedWaitTime}s wait)` : '';
                    showPublicMessage(`In queue: Position ${status.queuePosition} of ${status.queueSize}${waitTime}`, 'info');
                } else {
                    showPublicMessage('Left matchmaking queue', 'info');
                }
            });

            socket.on('matchFound', (matchData) => {
                console.log('🎉 Match found:', matchData);
                gameState.gameId = matchData.gameId;
                gameState.playerId = matchData.playerId;
                gameState.playerName = document.getElementById('publicPlayerName').value.trim();
                
                showPublicMessage(`Match found! Opponent: ${matchData.opponent}`, 'success');
                
                // Reset matchmaking state first
                gameState.publicMatchmaking = false;
                gameState.gameStatus = 'playing';
                
                // Hide ALL UI elements and show only the main game
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('publicMatchmaking').classList.add('hidden');
                document.getElementById('gameSetup').classList.add('hidden');
                document.getElementById('gameLobby').classList.add('hidden');
                document.getElementById('mainGame').classList.remove('hidden');
                
                // Reset the public matchmaking UI state
                resetPublicMatchmaking();
                
                console.log('🎮 Transitioning to game screen for public match');
            });

            socket.on('matchError', (errorData) => {
                console.error('❌ Match error:', errorData);
                showPublicMessage(errorData.error || 'Match creation failed. Please try again.', 'error');
                
                // Reset matchmaking state
                gameState.publicMatchmaking = false;
                gameState.gameStatus = 'menu';
                
                // Re-enable the join queue button
                const joinButton = document.querySelector('#publicMatchmaking button[onclick="joinPublicQueue()"]');
                if (joinButton) {
                    joinButton.disabled = false;
                    joinButton.textContent = 'Join Queue';
                }
            });
        }

        function updateConnectionStatus() {
            const statusEl = document.getElementById('connectionStatus');
            if (gameState.connected) {
                statusEl.className = 'connection-status connected';
                statusEl.textContent = 'Connected to server';
            } else {
                statusEl.className = 'connection-status disconnected';
                statusEl.textContent = 'Disconnected from server';
            }
        }

        // Game creation and joining functions
        function createGame() {
            console.log('🎮 CreateGame button clicked');
            
            const playerName = document.getElementById('playerName').value.trim();
            console.log('Player name:', playerName);
            
            if (!playerName) {
                console.log('❌ No player name provided');
                showMessage('Please enter your name', 'error');
                return;
            }
            
            console.log('Socket status:', socket ? 'exists' : 'null');
            console.log('Connection status:', gameState.connected);
            
            if (!socket) {
                console.log('❌ Socket not initialized, attempting to reconnect...');
                initializeSocket();
                setTimeout(() => createGame(), 2000); // Retry after 2 seconds
                return;
            }
            
            if (!gameState.connected) {
                console.log('❌ Not connected to server');
                showMessage('Not connected to server. Check console for details.', 'error');
                return;
            }

            console.log('🚀 Sending createGame request...');
            gameState.playerName = playerName;
            
            socket.emit('createGame', { playerName: playerName }, (response) => {
                console.log('📨 Received createGame response:', response);
                
                if (response && response.success) {
                    console.log('✅ Game created successfully!');
                    console.log('🎯 Setting gameState - GameID:', response.gameId, 'PlayerID:', response.playerId);
                    gameState.gameId = response.gameId;
                    gameState.playerId = response.playerId;
                    console.log('🎯 Current gameState:', gameState);
                    console.log('🚪 Calling showLobby()...');
                    showLobby();
                    console.log('🚪 showLobby() completed');
                } else {
                    console.log('❌ Failed to create game:', response);
                    showMessage(response?.error || 'Failed to create game', 'error');
                }
            });
        }

        function joinGame() {
            const playerName = document.getElementById('playerName').value.trim();
            const gameId = document.getElementById('gameId').value.trim();
            
            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }
            if (!gameId) {
                showMessage('Please enter a game ID', 'error');
                return;
            }
            if (!socket || !gameState.connected) {
                showMessage('Not connected to server', 'error');
                return;
            }

            gameState.playerName = playerName;
            socket.emit('joinGame', { gameId: gameId, playerName: playerName }, (response) => {
                if (response.success) {
                    gameState.gameId = gameId;
                    gameState.playerId = response.playerId;
                    showLobby();
                } else {
                    showMessage(response.error || 'Failed to join game', 'error');
                }
            });
        }

        function startMultiplayerGame() {
            if (!socket || !gameState.connected) {
                showMessage('Not connected to server', 'error');
                return;
            }

            socket.emit('startGame', {}, (response) => {
                if (!response.success) {
                    showMessage(response.error || 'Failed to start game', 'error');
                }
            });
        }

        // Public matchmaking functions
        function findPublicMatch() {
            const playerName = document.getElementById('publicPlayerName').value.trim();
            
            if (!playerName) {
                showPublicMessage('Please enter your name', 'error');
                return;
            }
            
            if (!socket || !gameState.connected) {
                showPublicMessage('Not connected to server', 'error');
                return;
            }

            gameState.playerName = playerName;
            gameState.publicMatchmaking = true;
            
            document.getElementById('findMatchBtn').textContent = '⏳ Searching...';
            document.getElementById('findMatchBtn').disabled = true;
            
            showPublicMessage('Joining matchmaking queue...', 'info');
            
            // Join public matchmaking queue
            socket.emit('joinPublicQueue', { playerName: playerName }, (response) => {
                if (response.success) {
                    showPublicMessage(`Added to queue (Position ${response.queuePosition})`, 'info');
                } else {
                    showPublicMessage(response.error || 'Failed to join matchmaking', 'error');
                    resetPublicMatchmaking();
                }
            });
        }

        function cancelPublicMatch() {
            if (gameState.publicMatchmaking && socket && gameState.connected) {
                socket.emit('leavePublicQueue', {}, (response) => {
                    if (response && response.success) {
                        showPublicMessage('Left matchmaking queue', 'info');
                    }
                });
            }
            
            gameState.publicMatchmaking = false;
            resetPublicMatchmaking();
        }

        function resetPublicMatchmaking() {
            document.getElementById('findMatchBtn').textContent = '🔍 Find Match';
            document.getElementById('findMatchBtn').disabled = false;
            gameState.publicMatchmaking = false;
        }


        function showPublicMessage(text, type) {
            const messageEl = document.getElementById('publicMatchStatus');
            if (messageEl) {
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
            }
        }

        function leaveGame() {
            if (socket && gameState.connected) {
                socket.disconnect();
            }
            
            // Stop any running timers and matchmaking
            stopClientTimer();
            cancelPublicMatch();
            
            gameState = {
                gameId: null,
                playerId: null,
                playerName: '',
                currentWord: '',
                currentGuess: '',
                currentRow: 0,
                gameStatus: 'waiting',
                players: [],
                playersAlive: 0,
                yourRank: 1,
                round: 1,
                score: 0,
                timer: 60,
                eliminationInProgress: false,
                connected: gameState.connected
            };

            showSetup();
        }

        // UI management functions
        function showMainMenu() {
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('publicMatchmaking').classList.add('hidden');
            document.getElementById('gameSetup').classList.add('hidden');
            document.getElementById('gameLobby').classList.add('hidden');
            document.getElementById('mainGame').classList.add('hidden');
        }

        function showPublicMatchmaking() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('publicMatchmaking').classList.remove('hidden');
            document.getElementById('gameSetup').classList.add('hidden');
            document.getElementById('gameLobby').classList.add('hidden');
            document.getElementById('mainGame').classList.add('hidden');
        }

        function showCustomGame() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('publicMatchmaking').classList.add('hidden');
            document.getElementById('gameSetup').classList.remove('hidden');
            document.getElementById('gameLobby').classList.add('hidden');
            document.getElementById('mainGame').classList.add('hidden');
        }

        function backToMainMenu() {
            // Stop any ongoing matchmaking
            if (gameState.publicMatchmaking) {
                cancelPublicMatch();
            }
            showMainMenu();
        }

        function showSetup() {
            showMainMenu(); // Redirect old calls to main menu
        }

        function showLobby() {
            console.log('🚪 showLobby() called - GameID:', gameState.gameId);
            document.getElementById('gameSetup').classList.add('hidden');
            document.getElementById('gameLobby').classList.remove('hidden');
            document.getElementById('mainGame').classList.add('hidden');
            
            document.getElementById('lobbyGameId').textContent = gameState.gameId;
            console.log('🚪 showLobby() UI updated, lobby should be visible');
        }

        function copyGameId() {
            const gameId = gameState.gameId;
            if (!gameId) return;
            
            navigator.clipboard.writeText(gameId).then(() => {
                const button = document.getElementById('copyGameIdBtn');
                const originalText = button.textContent;
                
                // Show feedback
                button.textContent = '✅ Copied!';
                button.classList.add('copied');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
                
                console.log('Game ID copied:', gameId);
            }).catch(err => {
                console.error('Failed to copy game ID:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = gameId;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                const button = document.getElementById('copyGameIdBtn');
                const originalText = button.textContent;
                button.textContent = '✅ Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        function showGame() {
            document.getElementById('gameSetup').classList.add('hidden');
            document.getElementById('gameLobby').classList.add('hidden');
            document.getElementById('mainGame').classList.remove('hidden');
            
            // Only reset if transitioning from waiting to playing (game start)
            if (gameState.gameStatus === 'waiting') {
                console.log('🔄 Game starting, resetting board');
                resetGameBoard();
            }
        }
        
        function resetGameBoard() {
            console.log('🔄 Resetting game board');
            
            // Clear all cells
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 5; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    if (cell) {
                        cell.textContent = '';
                        cell.classList.remove('filled', 'correct', 'present', 'absent', 'flipping');
                    }
                }
            }
            
            // Reset game state
            gameState.currentGuess = '';
            gameState.currentRow = 0;
            
            // Reset keyboard
            resetKeyboard();
            
            // Clear any shake animations
            const rows = document.querySelectorAll('.word-row');
            rows.forEach(row => row.classList.remove('shake'));
            
            // Reset opponent grid too
            setupOpponentGrid();
            
            console.log('🔄 Board reset complete');
            
            // Clear any point messages
            showMessage('New match starting!', 'info');
        }

        function forceCompleteReset() {
            console.log('🔥 FORCE COMPLETE RESET - Aggressive board clearing');
            
            // Extra aggressive cell clearing
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 5; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    if (cell) {
                        cell.textContent = '';
                        cell.innerHTML = '';
                        cell.className = 'letter-cell'; // Reset to base class only
                        cell.style.animation = '';
                        cell.style.transform = '';
                    }
                }
            }
            
            // Force reset game state
            gameState.currentGuess = '';
            gameState.currentRow = 0;
            
            // Aggressive keyboard reset
            const keyButtons = document.querySelectorAll('.key.letter');
            keyButtons.forEach(button => {
                button.className = 'key letter'; // Reset to base classes only
                button.style.background = '';
                button.style.color = '';
            });
            
            // Clear all animations and transitions
            const rows = document.querySelectorAll('.word-row');
            rows.forEach(row => {
                row.className = 'word-row'; // Reset to base class
                row.style.animation = '';
            });
            
            // Force recreation of opponent grid
            const opponentGrid = document.getElementById('opponentGrid');
            if (opponentGrid) {
                opponentGrid.innerHTML = '';
                setupOpponentGrid();
            }
            
            // Clear any pending timeouts/intervals that might cause issues
            setTimeout(() => {
                console.log('🔥 Force reset complete - board should be completely clean');
                console.log('🔥 Final state check - currentRow:', gameState.currentRow, 'currentGuess:', gameState.currentGuess);
                // Clear any leftover messages and show fresh start message
                showMessage('New tournament round starting!', 'info');
                // Double-check current row display
                updateCurrentRow();
            }, 100);
        }

        function updateGameFromServer(serverGameState) {
            console.log('🔄 updateGameFromServer called');
            console.log('🔄 Server status:', serverGameState.status);
            console.log('🔄 Tournament mode:', serverGameState.tournamentMode);
            console.log('🔄 Battle Royale:', serverGameState.isBattleRoyale);
            console.log('🔄 Current match:', serverGameState.currentMatch);
            console.log('🔄 Players count:', serverGameState.players?.length);
            console.log('🔄 Players alive:', serverGameState.playersAlive);
            console.log('🔄 Full server state:', serverGameState);
            
            // Store previous state for comparison
            const previousRound = gameState.round;
            const previousMatchId = gameState.currentMatch?.id;
            
            // Update state - handle both tournament and battle royale
            gameState.playersAlive = serverGameState.playersAlive;
            gameState.players = serverGameState.players;
            gameState.gameStatus = serverGameState.status;
            gameState.tournamentMode = serverGameState.tournamentMode;
            gameState.isBattleRoyale = serverGameState.isBattleRoyale;
            
            // Find current player first (used by both modes)
            const currentPlayer = serverGameState.players?.find(p => p.id === gameState.playerId);
            
            // Handle Battle Royale mode
            if (serverGameState.isBattleRoyale) {
                console.log('🔥 Processing Battle Royale update');
                
                // Update Battle Royale specific state
                if (serverGameState.playerProgress) {
                    gameState.currentRow = serverGameState.playerProgress.currentRow || 0;
                    gameState.garbageRows = serverGameState.playerProgress.garbageRows || 0;
                    gameState.maxRows = serverGameState.playerProgress.maxRows || 6;
                }
                
                // Update opponent info
                if (serverGameState.currentOpponent) {
                    gameState.currentOpponent = serverGameState.currentOpponent;
                }
                
                // Update timer
                if (serverGameState.gameTimer !== undefined) {
                    gameState.gameTimer = serverGameState.gameTimer;
                    gameState.gameTimerFormatted = serverGameState.gameTimerFormatted;
                }
                
                // Update rank/score from current player
                if (currentPlayer) {
                    gameState.yourRank = currentPlayer.rank;
                }
                
            } else {
                // Handle Tournament mode (existing logic)
            if (currentPlayer) {
                gameState.score = currentPlayer.score; // Tournament total
                gameState.currentMatchScore = currentPlayer.currentMatchScore || 0; // Live match score
                gameState.yourRank = currentPlayer.rank;
                
                // Always sync currentRow from server for new matches/rounds
                const serverRow = currentPlayer.currentRow || 0;
                if (serverRow !== gameState.currentRow) {
                    console.log('🔄 Row sync: client', gameState.currentRow, '-> server', serverRow);
                    gameState.currentRow = serverRow;
                    if (gameState.currentGuess === '') {
                        updateCurrentRow();
                    }
                }
            }
            }

            // Check for new round or new match BEFORE updating the state
            const isNewRound = serverGameState.round > previousRound;
            const isNewMatch = previousMatchId && serverGameState.currentMatch?.id && 
                              previousMatchId !== serverGameState.currentMatch.id;
            
            if (serverGameState.status === 'playing' && (isNewRound || isNewMatch)) {
                console.log('🔄 RESET TRIGGERED - New tournament round or match detected');
                console.log('🔄 Old round:', previousRound, '-> New round:', serverGameState.round);
                console.log('🔄 Old match ID:', previousMatchId);
                console.log('🔄 New match ID:', serverGameState.currentMatch?.id);
                console.log('🔄 Is new round:', isNewRound);
                console.log('🔄 Is new match:', isNewMatch);
                
                if (isNewRound) {
                    showRoundCountdown(serverGameState.round);
                }
                
                forceCompleteReset();
            }
            
            // Also check if player's currentRow is 0 but we have board content (desync fix)
            if (currentPlayer && currentPlayer.currentRow === 0 && gameState.currentRow > 0 && serverGameState.status === 'playing') {
                console.log('🔄 DESYNC DETECTED - Server says row 0, client has', gameState.currentRow);
                console.log('🔄 Forcing complete reset due to row desync');
                forceCompleteReset();
            }
            
            // Extra check: if server says we're at row 0, make sure client is too
            if (currentPlayer && currentPlayer.currentRow === 0 && serverGameState.status === 'playing') {
                console.log('🔄 Server confirms currentRow = 0, ensuring client sync');
                gameState.currentRow = 0;
                gameState.currentGuess = '';
            }
            
            // Update state after reset check (tournament mode)
            if (!serverGameState.isBattleRoyale) {
                gameState.round = serverGameState.round;
                gameState.currentMatch = serverGameState.currentMatch;
            }

            // Handle different game states
            if (serverGameState.status === 'waiting') {
                showLobby();
                updateLobby(serverGameState);
            } else if (serverGameState.status === 'playing') {
                showGame();
                updateGameDisplay();
                
                if (serverGameState.isBattleRoyale) {
                    console.log('🔥 Updating Battle Royale display');
                    updateBattleRoyaleDisplay(serverGameState);
                } else {
                    updateTournamentDisplay(serverGameState);
                }
            } else if (serverGameState.status === 'ended') {
                showGame();
                updateGameDisplay();
                if (serverGameState.isBattleRoyale) {
                    showMessage('Battle Royale Over!', 'info');
                } else {
                    showMessage('Tournament Over!', 'info');
                }
            }
        }

        function updateLobby(serverGameState) {
            document.getElementById('lobbyPlayerCount').textContent = `Players: ${serverGameState.players.length}/100`;
            
            const lobbyPlayerList = document.getElementById('lobbyPlayerList');
            lobbyPlayerList.innerHTML = '';
            
            // Show host information for custom games
            if (serverGameState.host && !serverGameState.isPublicMatch) {
                const hostInfo = document.createElement('div');
                hostInfo.textContent = `Host: ${serverGameState.host.name}`;
                hostInfo.style.padding = '8px';
                hostInfo.style.background = '#b59f3b';
                hostInfo.style.margin = '5px 0';
                hostInfo.style.borderRadius = '5px';
                hostInfo.style.fontWeight = 'bold';
                hostInfo.style.textAlign = 'center';
                lobbyPlayerList.appendChild(hostInfo);
            }
            
            serverGameState.players.slice(0, 10).forEach(player => {
                const playerDiv = document.createElement('div');
                let displayName = player.name;
                
                // Add host indicator
                if (serverGameState.host && player.id === serverGameState.host.id) {
                    displayName += ' 👑';
                }
                
                playerDiv.textContent = displayName;
                playerDiv.style.padding = '5px';
                playerDiv.style.background = player.id === gameState.playerId ? '#538d4e' : '#3a3a3c';
                playerDiv.style.margin = '2px';
                playerDiv.style.borderRadius = '5px';
                lobbyPlayerList.appendChild(playerDiv);
            });
            
            // Update start button visibility and state
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn) {
                const canStart = serverGameState.isHost && serverGameState.players.length >= 2;
                const isPublic = serverGameState.isPublicMatch;
                
                if (isPublic) {
                    // Hide start button for public matches (auto-start)
                    startBtn.style.display = 'none';
                } else {
                    // Show/hide and enable/disable for custom games
                    startBtn.style.display = serverGameState.isHost ? 'block' : 'none';
                    startBtn.disabled = !canStart;
                    
                    if (serverGameState.isHost) {
                        if (serverGameState.players.length < 2) {
                            startBtn.textContent = 'Need 2+ Players to Start';
                            startBtn.disabled = true;
                        } else {
                            startBtn.textContent = 'Start Game';
                            startBtn.disabled = false;
                        }
                    }
                }
            }
        }

        // Game input handling
        function handleKey(key) {
            if (gameState.gameStatus !== 'playing' || gameState.eliminationInProgress) return;

            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer || !currentPlayer.alive) return;

            if (key === 'ENTER') {
                submitGuess();
            } else if (key === 'BACKSPACE') {
                removeLetter();
            } else {
                addLetter(key);
            }
        }

        function addLetter(letter) {
            if (gameState.currentGuess.length < 5 && gameState.currentRow < 6) {
                gameState.currentGuess += letter;
                updateCurrentRow();
            }
        }

        function removeLetter() {
            if (gameState.currentGuess.length > 0) {
                gameState.currentGuess = gameState.currentGuess.slice(0, -1);
                updateCurrentRow();
            }
        }

        function submitGuess() {
            if (gameState.currentGuess.length !== 5) {
                showMessage('Word must be 5 letters long!', 'error');
                shakeRow();
                return;
            }

            if (!socket || !gameState.connected) {
                showMessage('Not connected to server', 'error');
                return;
            }

            const submittedGuess = gameState.currentGuess; // Store the guess before sending
            socket.emit('makeGuess', { guess: gameState.currentGuess }, (response) => {
                if (response.success) {
                    displayGuessResult(response.evaluation, submittedGuess);
                } else {
                    showMessage(response.error || 'Invalid word', 'error');
                    shakeRow();
                }
            });
        }

        function updateKeyboardColors(guess, result) {
            for (let i = 0; i < guess.length; i++) {
                const letter = guess[i];
                const letterResult = result[i];
                
                // Find the keyboard button for this letter
                const keyButtons = document.querySelectorAll(`.key.letter`);
                
                keyButtons.forEach(button => {
                    if (button.textContent === letter) {
                        // Only update if it's not already a better state
                        // Priority: correct > present > absent
                        if (!button.classList.contains('correct') || letterResult === 'correct') {
                            if (!button.classList.contains('present') || letterResult === 'correct' || letterResult === 'present') {
                                button.classList.remove('correct', 'present', 'absent');
                                button.classList.add(letterResult);
                            }
                        }
                    }
                });
            }
        }

        function displayGuessResult(evaluation, submittedGuess) {
            const { result, correct, completed, pointsEarned, totalScore, earlyBonus } = evaluation;
            
            // Make sure the submitted guess is displayed in the current row
            for (let i = 0; i < 5; i++) {
                const cell = document.getElementById(`cell-${gameState.currentRow}-${i}`);
                if (cell) {
                    // Set the letter first, then apply colors
                    cell.textContent = submittedGuess[i];
                    cell.classList.add('filled');
                    
                    setTimeout(() => {
                        cell.classList.add('flipping');
                        // Change color at the exact midpoint of the flip animation
                        setTimeout(() => {
                            cell.classList.remove('correct', 'present', 'absent');
                            cell.classList.add(result[i]);
                        }, 300); // Exactly at 50% of 0.6s animation
                        // Remove flipping class when animation completes
                        setTimeout(() => {
                            cell.classList.remove('flipping');
                        }, 600);
                    }, i * 100);
                }
            }

            // Clear current guess and advance to next row
            gameState.currentGuess = '';
            gameState.currentRow++;

            // Show scoring feedback
            if (correct) {
                let bonusText = '';
                if (earlyBonus > 0) {
                    bonusText = ` (+${earlyBonus} completion bonus!)`;
                }
                const roundText = gameState.round > 1 ? ` [Round ${gameState.round}]` : '';
                showMessage(`🎉 WORD SOLVED! ${totalScore} points${bonusText}${roundText}`, 'success');
            } else if (pointsEarned > 0) {
                const roundText = gameState.round > 1 ? ` (${gameState.round}x multiplier)` : '';
                showMessage(`+${pointsEarned} points${roundText}! Total: ${totalScore}`, 'info');
            }

            // Update keyboard colors after animation
            setTimeout(() => {
                updateKeyboardColors(submittedGuess, result);
            }, 800); // Wait for all animations to complete
        }

        function updateCurrentRow() {
            for (let i = 0; i < 5; i++) {
                const cell = document.getElementById(`cell-${gameState.currentRow}-${i}`);
                if (cell) {
                    if (i < gameState.currentGuess.length) {
                        cell.textContent = gameState.currentGuess[i];
                        cell.classList.add('filled');
                    } else {
                        cell.textContent = '';
                        cell.classList.remove('filled');
                    }
                }
            }
        }

        function showRoundCountdown(roundNumber) {
            console.log('🔥 Starting countdown for round', roundNumber);
            
            // Create countdown overlay
            const overlay = document.createElement('div');
            overlay.className = 'countdown-overlay';
            overlay.id = 'countdownOverlay';
            
            const title = document.createElement('div');
            title.className = 'countdown-title';
            title.textContent = `Round ${roundNumber} Starting...`;
            
            const numberDisplay = document.createElement('div');
            numberDisplay.className = 'countdown-number';
            numberDisplay.textContent = '5';
            
            overlay.appendChild(title);
            overlay.appendChild(numberDisplay);
            document.body.appendChild(overlay);
            
            let count = 5;
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    numberDisplay.textContent = count;
                    // Restart animation
                    numberDisplay.style.animation = 'none';
                    numberDisplay.offsetHeight; // Trigger reflow
                    numberDisplay.style.animation = 'countdownPulse 1s ease-in-out';
                } else {
                    numberDisplay.textContent = 'GO!';
                    numberDisplay.style.color = '#538d4e';
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                    }, 1000);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        function startClientTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }

            if (gameState.currentMatch && gameState.gameStatus === 'playing') {
                gameState.clientTimer = gameState.currentMatch.timer;
                
                gameState.timerInterval = setInterval(() => {
                    gameState.clientTimer = Math.max(0, gameState.clientTimer - 1);
                    updateTimerDisplay();
                    
                    if (gameState.clientTimer <= 0) {
                        clearInterval(gameState.timerInterval);
                    }
                }, 1000);
            }
        }

        function stopClientTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            const timer = gameState.clientTimer || 0;
            const minutes = Math.floor(timer / 60);
            const seconds = timer % 60;
            
            if (gameState.currentMatch && gameState.gameStatus === 'playing') {
                document.getElementById('timer').textContent = `⏱️ Match time remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Also update the match timer in sidebar
                const matchTimer = document.getElementById('matchTimer');
                if (matchTimer) {
                    matchTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            } else {
                document.getElementById('timer').textContent = '⏳ Waiting for match...';
            }
        }

        function updateGameDisplay() {
            document.getElementById('playersAlive').textContent = gameState.playersAlive;
            
            // Update garbage rows if in Battle Royale mode
            if (gameState.isBattleRoyale && gameState.garbageRows !== undefined) {
                updateGarbageRows(gameState.garbageRows);
            }
            
            // Show live match score during active matches, tournament total otherwise
            if (gameState.currentMatch && gameState.gameStatus === 'playing') {
                document.getElementById('yourScore').textContent = gameState.currentMatchScore || 0;
                document.getElementById('scoreLabel').textContent = 'Match Score';
            } else {
                document.getElementById('yourScore').textContent = gameState.score || 0;
                document.getElementById('scoreLabel').textContent = 'Total Score';
            }
            
            document.getElementById('roundNumber').textContent = gameState.round;
            document.getElementById('yourRank').textContent = gameState.yourRank;

            // Show/hide and update series score for public matches
            updateSeriesScore();

            updateTimerDisplay();
            updatePlayersList();
        }

        function updateGarbageRows(garbageCount) {
            console.log(`🗑️ Updating garbage rows: ${garbageCount} rows`);
            
            const wordGrid = document.getElementById('wordGrid');
            if (!wordGrid) return;
            
            // Clear existing garbage rows
            const existingGarbageRows = wordGrid.querySelectorAll('.word-row.garbage-row');
            existingGarbageRows.forEach(row => row.remove());
            
            // Add new garbage rows at the top
            for (let i = 0; i < garbageCount; i++) {
                const garbageRow = document.createElement('div');
                garbageRow.className = 'word-row garbage-row';
                
                for (let j = 0; j < 5; j++) {
                    const garbageCell = document.createElement('div');
                    garbageCell.className = 'letter-cell garbage';
                    garbageRow.appendChild(garbageCell);
                }
                
                // Insert at the beginning of the grid
                wordGrid.insertBefore(garbageRow, wordGrid.firstChild);
            }
            
            // Limit total rows to prevent overflow (6 regular rows + garbage rows)
            const allRows = wordGrid.querySelectorAll('.word-row');
            const maxRows = 6 + garbageCount;
            
            // Remove excess rows from the bottom if needed
            for (let i = allRows.length - 1; i >= maxRows; i--) {
                if (allRows[i] && !allRows[i].classList.contains('garbage-row')) {
                    allRows[i].remove();
                }
            }
            
            console.log(`🗑️ Added ${garbageCount} garbage rows to grid`);
        }

        function updateSeriesScore() {
            const seriesScoreEl = document.getElementById('seriesScore');
            
            if (gameState.isPublicMatch && gameState.seriesScore) {
                seriesScoreEl.classList.remove('hidden');
                
                const { player1, player2 } = gameState.seriesScore;
                
                document.getElementById('player1Name').textContent = player1.name;
                document.getElementById('player1Wins').textContent = player1.wins;
                document.getElementById('player2Name').textContent = player2.name;
                document.getElementById('player2Wins').textContent = player2.wins;
                
                // Highlight current player
                const player1Card = document.getElementById('player1Name').parentElement;
                const player2Card = document.getElementById('player2Name').parentElement;
                
                if (player1.id === gameState.playerId) {
                    player1Card.style.background = '#538d4e'; // Green for current player
                    player2Card.style.background = '#818384'; // Gray for opponent
                } else {
                    player2Card.style.background = '#538d4e'; // Green for current player
                    player1Card.style.background = '#818384'; // Gray for opponent
                }
            } else {
                seriesScoreEl.classList.add('hidden');
            }
        }

        function updateTournamentDisplay(serverGameState) {
            // Show/hide tournament elements
            if (gameState.tournamentMode && gameState.gameStatus === 'playing') {
                document.getElementById('tournamentInfo').classList.remove('hidden');
                document.getElementById('tournamentRound').textContent = gameState.round;
                document.getElementById('activeMatches').textContent = serverGameState.activeMatches || 0;

                if (gameState.currentMatch) {
                    // Show match info
                    document.getElementById('matchInfo').classList.remove('hidden');
                    document.getElementById('yourName').textContent = gameState.playerName;
                    document.getElementById('opponentName').textContent = gameState.currentMatch.opponent.name;
                    document.getElementById('opponentDisplayName').textContent = gameState.currentMatch.opponent.name;
                    
                    // Start or sync client timer
                    if (!gameState.timerInterval || Math.abs(gameState.clientTimer - gameState.currentMatch.timer) > 2) {
                        console.log('🕐 Starting/syncing client timer:', gameState.currentMatch.timer);
                        startClientTimer();
                    }

                    // Show opponent section and ensure grid is set up
                    document.getElementById('opponentSection').classList.remove('hidden');
                    
                    // Ensure opponent grid exists before updating
                    const opponentGrid = document.getElementById('opponentGrid');
                    if (!opponentGrid || opponentGrid.children.length === 0) {
                        setupOpponentGrid();
                    }
                    
                    updateOpponentGrid(gameState.currentMatch.opponentProgress);
                } else {
                    // Hide match-specific elements if no current match
                    document.getElementById('matchInfo').classList.add('hidden');
                    document.getElementById('opponentSection').classList.add('hidden');
                    stopClientTimer();
                }
            } else {
                document.getElementById('tournamentInfo').classList.add('hidden');
                document.getElementById('matchInfo').classList.add('hidden');
                document.getElementById('opponentSection').classList.add('hidden');
            }
        }

        function setupOpponentGrid() {
            const opponentGrid = document.getElementById('opponentGrid');
            if (!opponentGrid) {
                console.log('❌ Cannot setup opponent grid - element not found');
                return;
            }
            
            console.log('🔧 Setting up opponent grid - clearing existing content');
            opponentGrid.innerHTML = '';
            
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'opponent-row';
                
                for (let j = 0; j < 5; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'opponent-cell';
                    cell.id = `opponent-cell-${i}-${j}`;
                    row.appendChild(cell);
                }
                
                opponentGrid.appendChild(row);
            }
            
            console.log('✅ Opponent grid setup complete - created 30 cells (6 rows x 5 cols)');
            
            // Verify all cells are actually there
            const cellCount = opponentGrid.querySelectorAll('.opponent-cell').length;
            console.log(`🔍 Verification: Found ${cellCount} opponent cells in DOM`);
        }

        function updateOpponentGrid(opponentProgress) {
            console.log('🎯 Updating opponent grid with progress:', opponentProgress);
            
            // Ensure the grid exists first, but NEVER recreate if it already exists
            const opponentGrid = document.getElementById('opponentGrid');
            if (!opponentGrid || opponentGrid.children.length === 0) {
                console.log('⚠️ Opponent grid not found or empty, creating new one');
                setupOpponentGrid();
                return; // Exit and let the next update handle the coloring
            }
            
            // Reset ALL cells to their default empty state first
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 5; j++) {
                    const cell = document.getElementById(`opponent-cell-${i}-${j}`);
                    if (cell) {
                        // Remove color classes but keep the cell visible
                        cell.classList.remove('correct', 'present', 'absent');
                    }
                }
            }
            
            console.log(`🎯 Reset all 30 opponent cells to empty state`);

            // Now apply opponent's progress colors ONLY to cells with guesses
            if (opponentProgress && Array.isArray(opponentProgress)) {
                opponentProgress.forEach(guess => {
                    const row = guess.row;
                    if (row >= 0 && row < 6 && guess.result && Array.isArray(guess.result)) {
                        console.log(`🎨 Applying colors to row ${row}:`, guess.result);
                        guess.result.forEach((result, col) => {
                            if (col >= 0 && col < 5) {
                                const cell = document.getElementById(`opponent-cell-${row}-${col}`);
                                if (cell && ['correct', 'present', 'absent'].includes(result)) {
                                    cell.classList.add(result);
                                    console.log(`🎨 Applied ${result} to cell (${row}, ${col})`);
                                }
                            }
                        });
                    }
                });
            }
            
            console.log('🎯 Opponent grid update complete');
        }

        function updateBattleRoyaleDisplay(serverGameState) {
            console.log('🔥 Updating Battle Royale UI elements');
            
            // Hide tournament-specific elements
            document.getElementById('tournamentInfo').classList.add('hidden');
            document.getElementById('matchInfo').classList.add('hidden');
            
            // Always show opponent section in Battle Royale (even if no specific opponent yet)
            document.getElementById('opponentSection').classList.remove('hidden');
            
            // Set up opponent grid if needed
            const opponentGrid = document.getElementById('opponentGrid');
            if (!opponentGrid || opponentGrid.children.length === 0) {
                setupOpponentGrid();
            }
            
            // Show opponent info if we have a current opponent
            if (gameState.currentOpponent) {
                console.log('🎯 Showing opponent:', gameState.currentOpponent.name);
                document.getElementById('opponentDisplayName').textContent = gameState.currentOpponent.name;
                
                // Update opponent progress if available
                if (gameState.currentOpponent.progress) {
                    updateOpponentGrid(gameState.currentOpponent.progress);
                }
            } else {
                // Show placeholder for no opponent yet
                document.getElementById('opponentDisplayName').textContent = 'Searching for opponent...';
                
                // Reset opponent grid to empty state
                if (opponentGrid) {
                    for (let i = 0; i < 6; i++) {
                        for (let j = 0; j < 5; j++) {
                            const cell = document.getElementById(`opponent-cell-${i}-${j}`);
                            if (cell) {
                                cell.classList.remove('correct', 'present', 'absent');
                            }
                        }
                    }
                }
            }
            
            // Update global timer display for Battle Royale
            if (gameState.gameTimer !== undefined) {
                const minutes = Math.floor(gameState.gameTimer / 60);
                const seconds = gameState.gameTimer % 60;
                document.getElementById('timer').textContent = `🔥 Battle Royale: ${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
            } else {
                document.getElementById('timer').textContent = '🔥 Battle Royale Active';
            }
            
            // Update message for Battle Royale mode
            const messageEl = document.getElementById('message');
            if (messageEl && gameState.gameStatus === 'playing') {
                messageEl.textContent = 'Battle Royale mode: Eliminate opponents by solving words! Complete words to send garbage rows.';
                messageEl.className = 'message info';
            }
            
            // Update Battle Royale specific stats
            updateBattleRoyaleStats();
            
            // Update players list for Battle Royale
            updatePlayersList();
        }

        function updateBattleRoyaleStats() {
            console.log('🔥 Updating Battle Royale stats');
            
            // Update players alive count
            document.getElementById('playersAlive').textContent = gameState.playersAlive || 0;
            
            // Update your rank 
            document.getElementById('yourRank').textContent = gameState.yourRank || 1;
            
            // Update round number (Battle Royale doesn't have rounds, so show 1 or hide)
            document.getElementById('roundNumber').textContent = 1;
            
            // Update score (Battle Royale may not have traditional scores)
            const currentPlayer = gameState.players?.find(p => p.id === gameState.playerId);
            const displayScore = currentPlayer?.score || 0;
            document.getElementById('yourScore').textContent = displayScore;
            document.getElementById('scoreLabel').textContent = 'Score';
            
            console.log('🔥 Updated Battle Royale stats:', {
                playersAlive: gameState.playersAlive,
                yourRank: gameState.yourRank,
                yourScore: displayScore
            });
        }

        function updatePlayersList() {
            const playersList = document.getElementById('playersList');
            if (!playersList) return;
            
            playersList.innerHTML = '';
            
            // Handle different player filtering for Battle Royale vs Tournament
            let alivePlayers;
            if (gameState.isBattleRoyale) {
                // For Battle Royale, filter by 'alive' property
                alivePlayers = gameState.players ? gameState.players.filter(p => p.alive !== false) : [];
            } else {
                // For Tournament, filter by 'alive' property (existing logic)
                alivePlayers = gameState.players ? gameState.players.filter(p => p.alive) : [];
            }
            
            const topPlayers = alivePlayers.slice(0, 10);

            topPlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-item ${player.id === gameState.playerId ? 'you' : ''}`;
                
                const completedIcon = player.completedCurrentWord ? ' ✅' : '';
                
                // Show match score during active games, tournament total otherwise
                let displayScore;
                if (gameState.isBattleRoyale) {
                    // For Battle Royale, show player score or 0
                    displayScore = player.score || 0;
                } else {
                    // For Tournament, show match score during active games
                    displayScore = gameState.gameStatus === 'playing' && gameState.currentMatch 
                        ? player.currentMatchScore || 0 
                        : player.score || 0;
                }
                    
                playerDiv.innerHTML = `
                    <span class="player-name">#${index + 1} ${player.name}${completedIcon}</span>
                    <span class="player-score">${displayScore}</span>
                `;
                playersList.appendChild(playerDiv);
            });
            
            console.log('🎮 Updated players list:', {
                totalPlayers: gameState.players?.length || 0,
                alivePlayers: alivePlayers.length,
                displayedPlayers: topPlayers.length,
                isBattleRoyale: gameState.isBattleRoyale
            });
        }

        function shakeRow() {
            const currentRowEl = document.querySelector(`#wordGrid .word-row:nth-child(${gameState.currentRow + 1})`);
            if (currentRowEl) {
                currentRowEl.classList.add('shake');
                setTimeout(() => {
                    currentRowEl.classList.remove('shake');
                }, 500);
            }
        }

        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            if (messageEl) {
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
            }
        }

        function setupGrid() {
            const grid = document.getElementById('wordGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'word-row';
                
                for (let j = 0; j < 5; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'letter-cell';
                    cell.id = `cell-${i}-${j}`;
                    row.appendChild(cell);
                }
                
                grid.appendChild(row);
            }
            
            // Reset keyboard colors
            resetKeyboard();
        }

        function resetKeyboard() {
            const keyButtons = document.querySelectorAll('.key.letter');
            keyButtons.forEach(button => {
                button.classList.remove('correct', 'present', 'absent');
            });
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            initializeSocket();
            setupGrid();
            setupOpponentGrid();
            showSetup();
        });

        // Physical keyboard support
        document.addEventListener('keydown', function(e) {
            if (gameState.gameStatus !== 'playing') return;

            const key = e.key.toUpperCase();
            if (key === 'ENTER') {
                e.preventDefault();
                handleKey('ENTER');
            } else if (key === 'BACKSPACE') {
                e.preventDefault();
                handleKey('BACKSPACE');
            } else if (key.match(/^[A-Z]$/)) {
                e.preventDefault();
                handleKey(key);
            }
        });
    </script>
</body>
</html>